 Operators:
=================================================================================

001) Java provides a rich operator environment.
002) Most of Java operators can be divided into four basic groups: arithmetic,
     bitwise, relational, and logical.

---------------------------------------------------------------------------------

Arithmetic Operators:
---------------------------------------------------------------------------------

001) Arithmetic operators are used in mathematical expressions the same way they
     used in Java.
002) Java has the the following arithmetic operators:

Operator	Result
------------------------------------------------------------

+		Addition
-		Subtraction (Also unary minus)
*		Mutiplication
/		Division
%		Modulus
++		Increment
+=		Addition Assignment
-=		Subtraction Assignment
*=		Multiplication Assignment
/=		Division Assignment
%=		Modulus Assignment
--		Decrement

003) The following program demonstrates the arithmetic operators. It also demon-
     strates the difference between floating-point division and integer division:

public class basicArithmeticOperators {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		//Arithmetic operations with Integers
		System.out.println("Integer Arithmetic:");
		int ia = 1 + 1;
		int ib = ia * 3;
		int ic = ib / 4;
		int id = ic - ia;
		int ie = -id;
		
		System.out.println("Integer a = " + ia);
		System.out.println("Integer b = " + ib);
		System.out.println("Integer c = " + ic);
		System.out.println("Integer d = " + id);
		System.out.println("Integer e = " + ie);
		System.out.println();
		
		
		//Arithmetic operations with Integers
		System.out.println("Floating-point Arithmetic:");
		double da = 1 + 1;
		double db = da * 3;
		double dc = db / 4;
		double dd = dc - da;
		double de = -dd;
				
		System.out.println("Double a = " + da);
		System.out.println("Double b = " + db);
		System.out.println("Double c = " + dc);
		System.out.println("Double d = " + dd);
		System.out.println("Double e = " + de);
		
	}

}

004) The output generated by the above code is:

Integer Arithmetic:
Integer a = 2
Integer b = 6
Integer c = 1
Integer d = -1
Integer e = 1

Integer Arithmetic:
Double a = 2.0
Double b = 6.0
Double c = 1.5
Double d = -0.5
Double e = 0.5

005) Consider the following program which explains the incremend and decrement arithmetic
     operators:

public class complexArithmeticOperations {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		//Understanding the Increment Operator
		int a = 40;
		System.out.println("Original value of A: " + a);
		
		int b = a++;
		System.out.println("Value of A during post-increment operation: " + b);
		System.out.println("Value of A after post-increment operation: " + a);
		
		int c = ++a;
		System.out.println("Value of A during pre-increment operation: " + c);
		System.out.println("Value of A after pre-increment operation: " + a);
		System.out.println();
		
		//Understanding the Decrement Operator
		int x = 40;
		System.out.println("Original value of X: " + x);
		
		int y = x--;
		System.out.println("Value of X during post-decrement operation: " + y);
		System.out.println("Value of X after post-decrement operation: " + x);
		
		int z = --x;
		System.out.println("Value of X during pre-decrement operation: " + z);
		System.out.println("Value of X after pre-decrement operation: " + x);
	
	}

}

006) The above code provides the following output:

Original value of A: 40
Value of A during post-increment operation: 40
Value of A after post-increment operation: 41
Value of A during pre-increment operation: 42
Value of A after pre-increment operation: 42

Original value of X: 40
Value of X during post-decrement operation: 40
Value of X after post-decrement operation: 39
Value of X during pre-decrement operation: 38
Value of X after pre-decrement operation: 38

007) The following code explains the modulus operator:

public class modulusOperator {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		//Understanding the Modulus Operator
		int a = 42;
		double b = 42.5;
		System.out.println("Original value of A: " + a);
		System.out.println("Original value of B: " + b);
		
		System.out.println("A mod 10: " + a%10);
		System.out.println("B mod 10: " + b%10);
		System.out.println("A mod B: " + a%b);
		System.out.println("B mod A: " + b%a);
		
	}

}

008) The above code outputs the following values:

Original value of A: 42
Original value of B: 42.5
A mod 10: 2
B mod 10: 2.5
A mod B: 42.5
B mod A: 0.5

009) There are also arithmetic assignment operators which can be used to combine
     an arithmetic operation with an assignment.
010) The general syntax for these operations is:

variable = variable (operator) expression;

     However, with arithmetic assignment operators, the syntax is reduced to:

variable (operator)= expression;

011) Some examples:

     -- a = a + 4; becomes a += 4;
     -- b = b % 4; becomes b %= 4;

012) The assignment operator provides two benefits: Firstly, they save up on a lot
     of typing work, especially when used repeatedly. Secondly, the Java run-time
     system implements them more efficiently than their longer forms. This makes
     their use important in professionally written Java programs.

---------------------------------------------------------------------------------

The Bitwise Operators:
---------------------------------------------------------------------------------

001) Java defines several bitwise operators.
002) These can be operated on integer types, long, int, short, char, and byte.
003) The operators act upon the individual bits of the operands.

004) The bitwise operators are summarized as:

Operator	Result
-----------------------------------------------------------
-		Bitwise Unary NOT
&		Bitwise Unary AND
|		Bitwise Unary OR
^		Bitwise Exclusive OR
>>		Shift Right
>>>		Shift Right Zero Fill
<<		Shift Left
&=		Bitwise AND Assignment
|=		Bitwise OR Assignment
^=		Bitwise Exclusive OR Assignment
>>=		Shift Right Assignment
>>>=		Shift Right Zero Fill Assignment
<<=		Shift Left Assignment

005) Before we go ahead we must understand that Bitwise operators work on the 
     bit equivalents of values of any data. For example, take the number 45.
     The bitwise equivalent is 00101101. So, any bitwise operation done on the
     integer 45 would affect the value 00101101, the final output would be the 
     equivalent value.

006) Let us consider the below program to understand the Bitwise Logical Operators:

public class bitwiseLogicalOperators {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		String binary[] = {
							"0000",
							"0001",
							"0010",
							"0011",
							"0100",
							"0101",
							"0110",
							"0111",
							"1000",
							"1001",
							"1010",
							"1011",
							"1100",
							"1101",
							"1110",
							"1111"
		};
		
		int a = 3; // 0 + 2 + 1 or 0011 in binary
		int b = 6; // 4 + 2 + 0 or 0110 in binary
		
		int A_OR_B 		= a | b;
		int A_AND_B 		= a & b;
		int A_EXOR_B 		= a ^ b;
		int NOT_A		= ~ a;
		
		System.out.println("A: " + a);
		System.out.println("B: " + b);
		System.out.println("A OR B: " + A_OR_B);
		System.out.println("A AND B: " + A_AND_B);
		System.out.println("A EX-OR B: " + A_EXOR_B);
		System.out.println("NOT A: " + NOT_A);

	}

}

007) The output of the above program is:

A: 3
B: 6
A OR B: 7
A AND B: 2
A EX-OR B: 5
NOT A: -4

008) Next, we look into the Bitwise Shiting Operators. As previously, we need to
     understand that shifting operators act on the individual bits of a specific
     data type, and not the value itself.

009) Let's look into the following program to understand how the bitwise shifting
     operators work: 

public class bitwiseShiftOperators {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		// Left Shift Operator
		byte a = 32, b;
		int i, c;
		
		i = a << 2; // The binary value of 'a' is shifted by two positions to the left
		            // In this case, we see byte a = 32 (00100000)
					// So i = 128 (10000000)
		
		b = (byte) (a << 3); // In this case, we see that the binary value of 32 is
						     // shifted to the left by 3 positions.
							 // The final output would be, b = 256 (0001 00000000)
							 // However, since 'b' has been forcibly type-converted to
							 // 'byte', the value is trimmed to b = 0 (000000000)
		
		c = a << 3;	// Here, we see that the value is automatically type converted to
					// an integer value, and hence there will be no trimming done.
					// Also, since 'c' is of type 'int', the value gets deposited in the
					// variable without any issues.
		
		System.out.println("Integer A: " + a);
		System.out.println("A Left Shifted by 2: " + i);
		System.out.println("A Left Shifted by 3: " + b);
		System.out.println("A Left Shifted by 3 (Automatic type-conversion): " + c + '\n');

		// Right Shift Operator
		byte d = 64, e;
		
		e = (byte) (d >> 2); // This works similarly to the Left Shift Operator as explained above.
		
		System.out.println("Integer D: " + d);
		System.out.println("D Right Shifted by 2: " + e + '\n');
		
		// Let's see how Right Shift Operator works on negative values
		byte f = -16, g;
		
		g = (byte) (f >> 2); // The Right Shift operator works very differently on negative
							 // values. Fore example, the binary equivalent of -16 is 11101111,
							 // where the 1 in the MSB stands for the negative sign.
		
							 // On shifting this to the right by two spaces, we get
		 					 // 11111011, which in integer form is -4.
		
		System.out.println("Integer F: " + f);
		System.out.println("F Right Shifted by 2: " + g + '\n');
		
		// The Unsigned (Zero Fill) Right Shift Operator
		int h = -1, j; // The Unsigned Right Shift operator works even more differently.
					   // Let us take the example of -1. The value for -1 is
					   // 11111111 11111111 11111111 11111110. On shifting this to the
					   // right by 20 spaces, we get 00000000 00000000 00001111 11111111,
					   // which is equal to 4095 in the integer format.
		
		j = h >>> 20;
		
		System.out.println("Integer H: " + h);
		System.out.println("H Unsigned Right Shifted by 20 spaces: " + j + '\n');
		
	}

}

010) The output of the above program is:

Integer A: 32
A Left Shifted by 2: 128
A Left Shifted by 3: 0
A Left Shifted by 3 (Automatic type-conversion): 256

Integer D: 64
D Right Shifted by 2: 16

Integer F: -16
F Right Shifted by 2: -4

Integer H: -1
H Unsigned Right Shifted by 20 spaces: 4095

-------------------------------------------------------------------------------

Relational Operators:
-------------------------------------------------------------------------------

001) Relational operators determine the relationship one operator may have towards
     the other. They are used to determine order or equality.

002) The relational operators are:

Operator	Result
-------------------------------------------
==		Equal to
!=		Not equal to
>		Greater than
<		Lesser than
>=		Greater than or equal to
<=		Lesser than or equal to

-------------------------------------------------------------------------------

Boolean Logical Operators:
-------------------------------------------------------------------------------

001) Boolean Logical Operators operate only on Boolean values.
002) The list of boolean logical operators is as below:

Operator	Result
---------------------------------------------------
&		Logical AND
|		Logical OR
^		Logical EXOR
||		Short Circuit OR
&&		Short Circuit AND
!		Unary NOT
&=		AND Assignment
|=		OR Assignment
^=		EXOR Assignment
==		Equal to
!=		Not equal to
? :		Ternary if-then-else

003) The following code demonstrates the working of the Boolean Logical Operators:

public class booleanLogicalOperators {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		boolean a = true, b = false;
		boolean A_AND_B = a & b;
		boolean A_OR_B = a | b;
		boolean A_EXOR_B = a ^ b;
		boolean NOT_A = !a;
		
		System.out.println("A: " + a);
		System.out.println("B: " + b);
		System.out.println("A AND B: " + A_AND_B);
		System.out.println("A OR B: " + A_OR_B);
		System.out.println("A Ex-OR B: " + A_EXOR_B);
		System.out.println("NOT A: " + NOT_A);
		
	}

}

004) The output of the above code is:

A: true
B: false
A AND B: false
A OR B: true
A Ex-OR B: true
NOT A: false

005) Java includes a special 'ternary' operator that can replace certain types
     of if-then-else statements.
006) The '?' operator has the general form:

expression 1 ? expression 2 : expression 3;

007) Here, expression 1 would be any expression that evaluates to a Boolean value.
008) If expression 1 is true, then expression 2 is evaluated, otherwise expression
     3 is evaluated.
009) The following code explains this example well:

public class ternaryOperator {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		int i, k;
		
		i = 10;
		k = i < 10 ? -i : i;
		System.out.println("Absolute value of " + i + " is " + k);
		
		i = -10;
		k = i < 10 ? -i : i;
		System.out.println("Absolute value of " + i + " is " + k);
		
	}

}

010) The above code provides the following output: 

Absolute value of 10 is 10
Absolute value of -10 is 10


